<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Realtime Voice Bot</title>
  <style>
    body { font-family: sans-serif; padding: 20px; }
    #status { margin-bottom: 10px; }
  </style>
</head>
<body>
  <h2>ğŸ¤– Realtime Bot</h2>
  <p id="status">Connecting to WebSocket...</p>

  <script>
    const status = document.getElementById("status");

    // ×—×™×‘×•×¨ ×œÖ¾WebSocket ×©×œ ×”×©×¨×ª ×©×œ× ×•
    const ws = new WebSocket(`ws://${window.location.host}/`);

    ws.onopen = () => {
      console.log("âœ… Connected to WebSocket");
      status.textContent = "âœ… Connected";
    };

    ws.onclose = () => {
      console.log("âŒ Disconnected");
      status.textContent = "âŒ Disconnected";
    };

    ws.onerror = (err) => {
      console.error("âŒ WebSocket error", err);
      status.textContent = "âŒ WebSocket error";
    };

    // AudioContext ×œ× ×™×’×•×Ÿ ×‘×–××Ÿ ×××ª
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    ws.onmessage = (event) => {
      const msg = JSON.parse(event.data);

      if (msg.type === "output_audio_buffer.chunk" && msg.audio_base64) {
        const audioData = atob(msg.audio_base64);
        const buffer = new Uint8Array(audioData.length);
        for (let i = 0; i < audioData.length; i++) buffer[i] = audioData.charCodeAt(i);

        audioCtx.decodeAudioData(buffer.buffer, (decoded) => {
          const source = audioCtx.createBufferSource();
          source.buffer = decoded;
          source.connect(audioCtx.destination);
          source.start();
        });
      }
    };

    // ×¤×•× ×§×¦×™×” ×œ×”××¨×ª Float32Array ×œÖ¾PCM16Base64
    function float32ToPCM16Base64(float32Array) {
      const buffer = new ArrayBuffer(float32Array.length * 2);
      const view = new DataView(buffer);
      let offset = 0;
      for (let i = 0; i < float32Array.length; i++) {
        let s = Math.max(-1, Math.min(1, float32Array[i]));
        view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7fff, true);
        offset += 2;
      }
      let binary = "";
      const bytes = new Uint8Array(buffer);
      for (let i = 0; i < bytes.length; i++) binary += String.fromCharCode(bytes[i]);
      return btoa(binary);
    }

    async function startAudio() {
      try {
        const mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        const trackProcessor = new MediaStreamTrackProcessor({ track: mediaStream.getAudioTracks()[0] });
        const reader = trackProcessor.readable.getReader();

        // ×©×•×œ×— commit ×›×œ 200ms ×›×“×™ ×©×”×‘×•×˜ ×™×ª×—×™×œ ×œ×“×‘×¨ ×ª×•×š ×›×“×™
        let lastCommit = Date.now();
        const commitInterval = 200;

        while (true) {
          const { value, done } = await reader.read();
          if (done) break;

          if (value) {
            ws.send(JSON.stringify({
              type: "input_audio_buffer.append",
              audio: float32ToPCM16Base64(value.data)
            }));

            if (Date.now() - lastCommit > commitInterval) {
              ws.send(JSON.stringify({ type: "input_audio_buffer.commit" }));
              lastCommit = Date.now();
            }
          }
        }

        // ×¡×™×•× ×©×œ×™×—×ª ××•×“×™×•
        ws.send(JSON.stringify({ type: "input_audio_buffer.commit" }));

      } catch (e) {
        console.error("Error accessing audio:", e);
      }
    }

    startAudio();
  </script>
</body>
</html>
